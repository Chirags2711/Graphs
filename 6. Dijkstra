// Dijkstra: Single Source Shortest Path

// 1. Using PQ
class Pair{
    int distance;
    int node;
    public Pair(int d, int n){
        distance = d;
        node = n;
    }
}

class Solution{
    static int[] dijkstra(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj, int S) {
        // Write your code here
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MAX_VALUE);
        fun(S, adj, dist);
        return dist;
    }
    static void fun(int S, ArrayList<ArrayList<ArrayList<Integer>>> adj, int[] dist){
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance);
        dist[S] = 0;
        pq.offer(new Pair(0, S));
        while(!pq.isEmpty()){
            Pair p = pq.poll();
            int currNode = p.node;
            int currDist = p.distance;
            for(List<Integer> neiList: adj.get(currNode)){
                int nei = neiList.get(0);
                int edgeWt = neiList.get(1);
                if(currDist + edgeWt < dist[nei]){
                    dist[nei] = currDist + edgeWt;
                    pq.offer(new Pair(dist[nei], nei));
                }
            }
        }
    }
}

// 2. Priority Queue with removal

class Pair{
    int distance;
    int node;
    public Pair(int d, int n){
        distance = d;
        node = n;
    }
    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof Pair)) {
            return false;
        }
        Pair c = (Pair) o;
        return Double.compare(node, c.node) == 0;
    }
}

class Solution{
    static int[] dijkstra(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj, int S) {
        // Write your code here
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MAX_VALUE);
        fun(S, adj, dist);
        return dist;
    }
    static void fun(int S, ArrayList<ArrayList<ArrayList<Integer>>> adj, int[] dist){
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance);
        dist[S] = 0;
        pq.offer(new Pair(0, S));
        while(!pq.isEmpty()){
            Pair p = pq.poll();
            int currNode = p.node;
            int currDist = p.distance;
            for(List<Integer> neiList: adj.get(currNode)){
                int nei = neiList.get(0);
                int edgeWt = neiList.get(1);
                if(currDist + edgeWt < dist[nei]){
                    pq.remove(new Pair(dist[nei], nei)); // any distance, does not matter. My custom equals method compares node only
                    dist[nei] = currDist + edgeWt;
                    pq.offer(new Pair(dist[nei], nei));
                }
            }
        }
    }
}
